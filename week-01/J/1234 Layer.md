# Physical Layer & Data Link Layer

### 물리 계층

OSI 7계층 중 가장 최하위 계층으로 비트 신호를 주고받는 계층

컴퓨터는 0과 1만을 이해할 수 있기 때문에 네트워크를 통해 주고받는 정보도 0과 1로 이루어진 신호로 구성된다.

물리 계층은 이런 신호를 유무선 통신 매체를 통해 운반한다.

### 데이터 링크 계층

같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층

같은 네트워크에 속한 호스트를 식별하는 MAC 주소 사용하고 물리 계층을 통해 주고받는 정보에 오류가 없는지 확인한다.

>> 물리 계층과 데이터 링크 계층은 서로 밀접하게 연관되어 있으며 하드웨어와 밀접하게 맞닿아 있는 계층

## Ethernet

> 이더넷(Ethernet) 은 LAN에서 데이터를 송수신하는 방법,
> 
> 
> 프레임 구조, 신호 전송 방식 등을 정의한 기술이다.
> 

현재 대부분의 **유선 LAN(Local Area Network)** 은 이더넷 기반으로 동작한다.

### 이더넷 표준 (IEEE 802.3)

이더넷은 **IEEE 802.3** 으로 국제 표준화되어 있다.

서로 다른 제조사의 장비도 같은 네트워크에서 호환되는 이유는

모두 이 표준을 따르기 때문이다.

| 표준명 | 알려진 이름 | 전송 속도 |
| --- | --- | --- |
| IEEE 802.3 | 이더넷 (Ethernet) | 10 Mbps |
| IEEE 802.3u | 고속 이더넷 (Fast Ethernet) | 100 Mbps |
| IEEE 802.3z / 802.3ab | 기가비트 이더넷 (Gigabit Ethernet) | 1 Gbps |
| IEEE 802.3ae | 10기가비트 이더넷 | 10 Gbps |
| IEEE 802.3ba | 100기가비트 이더넷 | 100 Gbps |
| IEEE 802.3bz | 2.5기가비트 이더넷 | 2.5 Gbps |

> 표준이 달라지면 통신 매체, 신호 방식, 전송 속도 등이 달라질 수 있다.
> 

## Ethernet Frame

이더넷 네트워크에서 실제로 주고받는 데이터를 **이더넷 프레임(Ethernet Frame)** 이라 한다.

(현재 대부분 **Ethernet II 프레임** 사용)

| 구분 | 설명 | 크기(Byte) |
| --- | --- | --- |
| **프리앰블 (Preamble)** | 송수신 동기화용 비트 패턴 | 8 |
| **수신지 MAC 주소** | 목적지 호스트의 물리 주소 | 6 |
| **송신지 MAC 주소** | 송신 호스트의 물리 주소 | 6 |
| **타입/길이 (Type/Length)** | 상위 계층 프로토콜 식별 or 프레임 길이 | 2 |
| **데이터 (Payload)** | 실제 전달할 데이터 | 46 ~ 1500 |
| **FCS (Frame Check Sequence)** | 오류 검출용 CRC 값 | 4 |

![image.png](attachment:cbebf8f9-347e-45f9-b23e-9077dbf2b7dc:image.png)

### ① 프리앰블 (Preamble)

- 송수신 측의 **동기화(Synchronization)** 를 위해 사용
- 7바이트: `10101010`, 마지막 1바이트: `10101011`
- 수신 측은 이 패턴을 감지하여 “이더넷 프레임이 들어오고 있다”고 인식

### ② MAC 주소 (Source / Destination)

- **48비트(6바이트)** 주소로, 네트워크 인터페이스 카드(NIC)에 고유하게 부여된다.
- 예: `ab:cd:ef:12:34:56`
- 프레임에는 **송신지 MAC 주소**와 **수신지 MAC 주소**가 모두 포함된다.
- 같은 호스트라도 NIC가 여러 개면 MAC 주소도 여러 개 존재한다.

### ③ 타입 / 길이 (Type / Length)

- 값이 **1500 이하** → 프레임 길이
- 값이 **1536(0x0600) 이상** → 상위 계층 프로토콜 타입
    - IPv4 → `0x0800`
    - ARP → `0x0806`

### ④ 데이터 (Payload)

- 실제 전송할 데이터가 담긴 영역
- 최대 크기: **1500바이트 (MTU: Maximum Transmission Unit)**
- 이보다 큰 데이터는 여러 프레임으로 분할 전송
- 예외적으로 더 큰 크기의 “**점보 프레임 (Jumbo Frame)**” 도 존재

### ⑤ FCS (Frame Check Sequence)

- 프레임의 **오류 검출**을 위한 4바이트 필드
- 송신 측: 데이터 + CRC 값 계산 후 전송
- 수신 측: 받은 데이터의 CRC 다시 계산 → 두 값 비교
    - 일치 → 정상
    - 불일치 → 오류로 간주

## 통신 매체

### 유선 통신 매체 — 트위스티드 페어 케이블

LAN에서 가장 많이 사용되는 유선 매체는 **트위스티드 페어 케이블 (Twisted Pair Cable)** 이다.

- 두 가닥의 구리선을 서로 꼬아서 전자기 간섭(노이즈)을 줄임
- 커넥터: **RJ-45 (LAN 케이블 커넥터)**
- 카테고리(Category, Cat) 별로 성능이 다름

| 카테고리 | 표기 | 최대 속도 | 주요 표준 |
| --- | --- | --- | --- |
| Cat5 | 100 Mbps | 100BASE-T |  |
| Cat5e | 1 Gbps | 1000BASE-T |  |
| Cat6 | 1 Gbps | 1000BASE-TX |  |
| Cat6a | 10 Gbps | 10GBASE-T |  |
| Cat7 | 10 Gbps | 10GBASE-T |  |
| Cat8 | 40 Gbps | 40GBASE-T |  |

**차폐(Shielding)**

트위스티드 페어 케이블은 전자기 간섭(Noise)을 줄이기 위해

**실드(Shield)** 로 감싸는 경우가 있다.

| 표기 | 의미 |
| --- | --- |
| **UTP (Unshielded Twisted Pair)** | 실드 없음 |
| **STP (Shielded Twisted Pair)** | 브레이드 실드로 외부 차폐 |
| **FTP (Foiled Twisted Pair)** | 포일 실드로 차폐 |
| **S/FTP** | 외부 브레이드 실드 + 내부 포일 실드 |
| **SF/FTP** | 이중 차폐(브레이드 + 포일) 구조 |

> 실드의 표기는 외부 실드 / 내부 실드 순으로 표현된다.
> 
> 
> 예: `S/FTP` → 외부 브레이드 + 내부 포일 실드
> 

### 무선 매체 — 전파와 Wi-Fi

유선 LAN의 대표가 이더넷이라면,

무선 LAN의 대표는 바로 **Wi-Fi** 다.

- 표준: **IEEE 802.11**
- 주파수 대역: **2.4GHz, 5GHz (최근엔 6GHz도 등장)**
- 세대별 표준 규격:

| 세대 | 표준 규격 | 최대 속도 |
| --- | --- | --- |
| Wi-Fi 4 | IEEE 802.11n | 600 Mbps |
| Wi-Fi 5 | IEEE 802.11ac | 3.5 Gbps |
| Wi-Fi 6 | IEEE 802.11ax | 9.6 Gbps |
| Wi-Fi 7 | IEEE 802.11be | 46 Gbps (예상) |

> 주파수 간섭을 줄이기 위해 채널(Channel) 을 분리해 사용
> 
> 
> 2.4GHz 대역에서는 **1, 6, 11번 채널**을 사용하는 것이 가장 안정적이다.
> 

**AP와 SSID**

- **AP (Access Point)** : 무선 네트워크의 중심 장비 (무선 공유기)
- **SSID (Service Set Identifier)** : 네트워크 식별자, 즉 Wi-Fi 이름
- 하나의 AP는 여러 SSID를 가질 수 있고,
    
    SSID를 통해 사용자는 특정 무선 네트워크에 접속한다.
    

## 네트워크 장비

### NIC (Network Interface Controller)

> NIC = 네트워크 인터페이스 카드
> 
> 
> 네트워크 인터페이스의 하드웨어 구현체
> 
- 송신 시: 호스트의 데이터를 프레임으로 변환해 전송
- 수신 시: 수신된 신호를 프레임으로 변환해 CPU로 전달
- 각 NIC에는 고유한 **MAC 주소**가 부여됨
- 대부분의 PC는 메인보드에 **내장 NIC** 를 포함

**NIC 성능 확장: 티밍(Teaming) / 본딩(Bonding)**

여러 NIC를 하나의 고속 NIC처럼 묶어 사용하는 방식

| 운영체제 | 용어 | 설명 |
| --- | --- | --- |
| Windows | Teaming | NIC 다중 연결 구성 |
| Linux | Bonding | NIC 다중 연결 구성 |

마치 **RAID** 처럼 여러 물리 장치를 하나의 논리 장치로 묶어

속도와 안정성을 동시에 확보할 수 있다.

### 허브(Hub) vs 스위치(Switch)

| 구분 | 허브 (Hub) | 스위치 (Switch) |
| --- | --- | --- |
| 계층 | 물리 계층 (1계층) | 데이터 링크 계층 (2계층) |
| 동작 방식 | 받은 신호를 **모든 포트로 송출** | 목적지 포트로만 송출 |
| 통신 방식 | **반이중 (Half Duplex)** | **전이중 (Full Duplex)** |
| 충돌 도메인 | 전체 호스트 공유 | 포트별로 분리 |
| 사용 여부 | 거의 사용 안 함 | 대부분의 LAN에서 사용 |

**스위치의 주요 기능**

**① MAC 주소 학습 (MAC Address Learning)**

![image.png](attachment:1ced977f-4add-4684-995d-a515cac5a865:image.png)

- 스위치는 수신한 프레임의 **송신지 MAC 주소**를 학습해
    
    **어떤 포트에 어떤 호스트가 연결되어 있는지** 기록
    
- 이를 **MAC 주소 테이블**에 저장 후, 목적지 포트로만 전송

**② VLAN (Virtual LAN)**

![image.png](attachment:72706c16-a818-4a86-a5cb-12491dcf43c8:image.png)

- 하나의 스위치를 여러 개의 논리적 네트워크로 분리
- 서로 다른 VLAN은 **브로드캐스트 도메인 분리**
- VLAN 간 통신을 위해서는 **L3(네트워크 계층) 장비** 필요

# Network Layer

네트워크 간 통신을 가능하게 하는 계층

데이터 링크 계층이 기본적으로 같은 LAN에 속한 호스트끼리 올바르게 정보를 주고받기 위한 계층이면, 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받기 위한 계층이다.

>> 네트워크간 통신 과정에서 호스트를 식별할 수 있는 주소(IP 주소) 필요

## Internet Protocol

IP는 네트워크 계층의 핵심 프로토콜로, **네트워크 간 통신을 가능하게 하는 주소 체계**

### IP의 목적

**주소 지정(Addressing)**

- 네트워크 상에서 **각 호스트(컴퓨터)를 구분하기 위한 식별자**
- IP 패킷 헤더의 **송신지 IP 주소**, **수신지 IP 주소** 필드를 통해 이루어짐
- 택배 비유:
    - MAC 주소: 수신인 이름
    - IP 주소: 수신지 주소

![image.png](attachment:cfb76763-66e8-4889-9033-a527858f4ebd:image.png)

> 네트워크 간 통신에서 MAC 주소보다 IP 주소가 우선적으로 사용된다.
> 
> 
> 라우팅은 오직 IP 주소로 이루어진다.
> 

**단편화(Fragmentation)**

- 패킷이 네트워크에서 허용하는 최대 크기(MTU)를 넘으면
    
    → 여러 개의 IP 조각(fragment)으로 나눠 전송
    
- 수신지가 다시 조립(reassembly)

**MTU (Maximum Transmission Unit)**

- 일반적인 MTU는 **1500바이트**
- 프레임에서 담을 수 있는 최대 데이터(payload) 크기와 동일

**단편화와 관련된 IP 헤더 필드**

| 필드 | 설명 |
| --- | --- |
| **Identification** | 같은 원본 데이터에서 쪼개진 패킷을 구별하는 번호 |
| **Flags (DF, MF)** | DF: 단편화 금지(Don’t Fragment) / MF: 뒤에 단편 더 있음 |
| **Fragment Offset** | 조립할 때 원래 데이터에서 몇 바이트 떨어져 있는지 |

**단편화를 피하는 기술: Path MTU Discovery**

- 실제 통신 경로에서 처리 가능한 최소 MTU를 찾고
    
    → **그보다 작은 크기로 데이터 전송**
    
- 오늘날 네트워크는 대부분 이 기능을 써서 단편화를 잘 발생시키지 않는다.

**단편화를 피하는 이유**

잦은 IP 단편화는 네트워크에 여러 악영향을 미친다.

- 단편화된 패킷들이 많아지면 전송해야할 **패킷의 헤더들이 많아지기 때문에**
- **불필요한 트래픽 증가**와 **대역폭 낭비**를 초래하고
- 단편화된 **패킷을 재조립하는 과정에서 발생하는 부하**도 성능 저하로 이어진다.

### IP의 특징

**비신뢰성(Unreliable)**

- 패킷이:
    - 손실되거나
    - 중복되거나
    - 순서가 바뀌어 도착해도
        
        **IP는 아무런 조치를 하지 않는다**
        
- “Best-effort delivery”
    - *최선을 다하지만, 보장은 없다*

**비연결형(Connectionless)**

- 사전에 연결을 맺지 않는다 (TCP와 반대)
- 그냥 목적지 IP만 보고 패킷을 던진다

> 이러한 비연결형 + 비신뢰성 특성을 보완하려고 나온 것이
> 
> 
> → **TCP (신뢰성 보장 계층)**
> 
> → **ICMP (전송 상태 피드백)**
> 

### IP 패킷 구조 (IPv4 Header)

중요한 필드만 추려서 정리:

| 필드 | 설명 |
| --- | --- |
| Version | IPv4 = 4 |
| Header Length | 헤더 길이 |
| Total Length | 패킷 전체 크기 |
| **Identification** | 단편화 시 패킷 구분 |
| **Flags (DF/MF)** | 단편화 옵션 |
| **Fragment Offset** | 조립 순서 |
| **TTL** | 라우터를 지날 때 1씩 감소 (0되면 폐기) |
| Protocol | 상위 계층 프로토콜 번호 (TCP=6, UDP=17) |
| **Source IP** | 출발지 |
| **Destination IP** | 목적지 |
| Checksum | 헤더 오류 검증 |

### IP 주소의 기본 구조

IPv4 주소는 **32비트 = 4바이트 = 4개의 옥텟**

예: `192.168.0.1`

![image.png](attachment:b9b0a89c-67f0-453b-a86f-b9ef1e924325:image.png)

네트워크 주소는 **네트워크를 구별**,

호스트 주소는 **그 네트워크 안의 호스트를 구별**한다.

### 클래스풀(Classful) 주소 체계

IP 주소를 A/B/C 클래스로 나누어 네트워크 크기를 정해 둔 전통적 방식.

![image.png](attachment:2240b258-88df-48e6-a9b5-adde3e3c8cb4:image.png)

| 클래스 | 첫 번째 옥텟 범위 | 네트워크/호스트 구조 |
| --- | --- | --- |
| A | 0~127 | N . H . H . H |
| B | 128~191 | N . N . H . H |
| C | 192~223 | N . N . N . H |

→ 지금은 거의 사용되지 않지만 개념 이해용으로 중요.

### 클래스리스 주소 체계(CIDR)

지금의 인터넷에서 사용하는 방식.

서브넷 마스크를 이용해 **네트워크/호스트 비율을 자유롭게 조절**할 수 있다.

**Subnet Mask**

IP 주소상에서 네트워크 주소를 1로 표기하고 호스트 주소를 0으로 표기한 비트열

서브넷을 구분하는 비트열

**Subnetwork**

IP 주소에서 네트워크 주소로 구분할 수 있는 네트워크의 부분집합

**서브넷 마스크 예시**

- 255.255.255.0 → /24
- 255.255.252.0 → /22

```
192.168.200.102 / 24
서브넷 마스크: 255.255.255.0
비트 AND 연산
네트워크 주소: 192.168.200.0
```

### 공인 IP vs 사설 IP

**공인 IP (Public IP)**

- 전 세계에서 **고유한 주소**
- ISP가 할당
- 인터넷 통신 시 외부에서 보이는 IP

**사설 IP (Private IP)**

- 내부(LAN)에서 사용
- 외부에서는 식별 불가
- 보통 라우터가 NAT를 통해 공인 IP로 변환

**사설 IP 대표 범위**

- 10.0.0.0/8
- 172.16.0.0/12
- 192.168.0.0/16

### IP 주소 할당 방식

**정적 할당 (Static)**

운영자가 직접:

- IP 주소
- 서브넷 마스크
- 게이트웨이
- DNS

를 설정한다.

**Gateway**

![image.png](attachment:aef9d62b-a4ac-4e93-8dcc-90b321af3908:image.png)

서로 다른 네트워크를 연결하는 하드웨어/소프트웨어적 수단

그 중 기본 게이트웨이는 호스트가 속한 네트워크의 외부로 나가기 위한 첫 기본 경로

따라서 **기본 게이트웨이는 네트워크 외부와 연결된 라우터의 주소를 의미**하는 경우가 많다.

**DNS**

호스트가 **도메인 네임을 토대로 IP 주소를 알아내기 위해 질의하는 서버의 주소**

기본적으로 호스트끼리 패킷을 주고받는 데에 IP 주소가 사용되지만

통신을 주고받는 모든 호스트의 IP 주소를 기억하기 어렵다.

따라서 IP 주소에 대응되는 기억할 수 있는 문자열로 호스트 식별 가능

>> 도메인 네임

![image.png](attachment:8b03794a-2ae6-4823-b53d-24ada5707661:image.png)

호스트가 도메인 네임을 토대로 이에 대응되는 IP 주소를 알아내려면

<도메인 네임, IP 주소> 쌍을 저장하는 DNS 서버에 질의해야 한다.

**동적 할당 (DHCP, Dynamic Host Configuration Protocol)**

자동으로 IP를 부여받음

- 임대 기간 존재 (Lease Time)
- 같은 호스트도 매번 IP가 바뀔 수 있음

### IP의 비신뢰성을 보완: ICMP(Internet Control Message Protocol)

ICMP는 IP 전송 과정에 대한 **피드백 메시지** 프로토콜.

**대표 ICMP 메시지**

- Destination network unreachable 네트워크 도달 불가
- Destiantion host unreachable 호스트 도달 불가
- Destination protocol unreachable 프로토콜 도달 불가, 수신지에서 특정 프로토콜 사용 불가
- Destination port unreachable 포트 도달 불가
- Fragmentation required, and DF flag set 단편화가 필요하지만 DF가 1이라 단편화 불가
- TTL expired TTL 만료
- Echo request/reply 에코 요청/응답

### IP ↔ MAC 주소를 연결시키는 ARP(Address Resolution Protocol)

IP 주소만으로는 LAN에서 통신할 수 없기 때문에

**IP → MAC 주소를 알아내는 프로토콜**이 필요하다. 그게 ARP.

**ARP 동작 과정**

1. ARP Request (브로드캐스트)
    
    ![image.png](attachment:516a662b-c1df-4ce6-a475-17920484bb5f:image.png)
    
    > “이 IP 가진 애 누구야? MAC 주소 알려줘!”
    > 
2. 해당 호스트만 ARP Reply(유니캐스트)
    
    ![image.png](attachment:4a3ed917-a1b2-4cf5-97e3-0e473915960b:image.png)
    
    > “내 MAC은 XX-XX-XX야”
    > 
3. 요청자는 (IP, MAC) 쌍을 **ARP 테이블**에 저장

# Transport Layer

네트워크를 통해 송수신되는 패킷은 전송 도중 유실의 가능성과 순서가 바뀌는 가능성이 있다.

전송 계층은 이런 상황에 대비해 신뢰성 있는 전송을 가능하게 하는 계층

또한 Port를 통해 특정 응용 프로그램과의 연결 다리를 수행하는 계층

## 포트를 통한 프로세스 식별

네트워크 통신에서 패킷은 **호스트(컴퓨터)** 가 목적지가 아닌,

**호스트 내부의 특정 프로세스(애플리케이션)** 로 전달되어야 한다.

이를 위해 **포트 번호(port number)** 를 사용한다.

- IP 주소 = "어느 컴퓨터인가"
- 포트 번호 = "그 컴퓨터 안의 어떤 프로그램인가"

> 예) 192.168.0.10:8080
> 

### 포트 번호 범위

| 종류 | 범위 | 설명 |
| --- | --- | --- |
| **Well-known Port** | 0 ~ 1023 | 가장 대중적인 서비스 (HTTP 80, HTTPS 443, DNS 53 등) |
| **Registered Port** | 1024 ~ 49151 | 자주 사용되는 서비스 (MySQL 3306, Redis 6379 등) |
| **Dynamic Port** | 49152 ~ 65535 | 클라이언트 프로그램이 임시로 사용하는 포트 |

## NAT & NAPT

**NAT**(Network Address Translation)은 사설 IP ↔ 공인 IP 변환 기술이다.

공유기 안의 여러 사설 IP를 하나의 공인 IP로 묶을 때 포트를 기준으로 구분하는데, 이 방식이 **NAPT**이다.

```
192.168.0.5:1030 → 1.2.3.4:6200
192.168.0.6:1040 → 1.2.3.4:6201
```

포트 번호 덕분에 여러 기기가 하나의 공인 IP를 공유할 수 있다.

## TCP vs UDP

### TCP (신뢰성 기반 / 연결형)

TCP는 신뢰성 높은 전송을 위해 다양한 기능을 제공한다.

- **연결형(Handshake 필요)**
- **신뢰성 보장**
    - 흐름 제어
    - 오류 제어(재전송)
    - 혼잡 제어
- **순서 보장(Sequence Number)**
- **정확성 중요 서비스에 사용**
    - 웹(HTTP), 파일 전송, DB 통신 등

### TCP 헤더의 핵심

![image.png](attachment:19e7da20-c111-44f6-bb72-4f6cd16974ea:image.png)

**Sequence Number**

TCP 패킷의 **올바른 송수신 순서를 보장**하기 위해 세그먼트 첫 바이트에 매겨진 번호

현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지 확인 가능

**ACK Number** 

![image.png](attachment:015cc35b-b7a1-4a78-ba3d-c43701af5ccd:image.png)

상대 호스트가 보낸 세그먼트에 대한 응답, **다음으로 수신하길 기대하는 순서 번호**

일반적으로 **올바르게 수신한 순서 번호에 1이 더해진 값**

**Control Bits, flag bits**

현재 세그먼트에 대한 부가 정보

- SYN: 연결 요청
- ACK: 세그먼트 승인
- FIN: 연결 종료

### UDP (비신뢰성 / 비연결형)

UDP는 매우 단순한 프로토콜이다.

- **연결 수립 없음**
- **오류 제어 없음**
- **순서 보장 없음**
- **빠름, 오버헤드 낮음**
- **스트리밍·게임 등에 사용**

### UDP 헤더 구성

![image.png](attachment:1af95bbe-81e0-4292-8bc7-b84ef3714180:image.png)

- 송신지 포트
- 수신지 포트
- 길이
- 체크섬: 송수신 과정에서의 데이터그램 훼손 여부 정보

## TCP의 연결 수립 (Three-Way Handshake)

TCP는 데이터를 주고받기 전에 **연결을 먼저 만든다**.

![image.png](attachment:08625872-753f-4b3b-8899-e9e379211ffd:image.png)

1. **A → B : SYN**
- 호스트 A는 SYN 비트가 1로 설정된 세그먼트를 B에게 전송
- 세그먼트의 순서 번호에는 A의 순서 번호가 포함

1. **B → A : SYN + ACK**
- 1에 대한 B의 응답
- B는 ACK 비트와 SYN 비트가 1로 설정된 세그먼트를 A에게 전송
- 세그먼트의 순서 번호에는 B의 순서 번호와 1에서 보낸 세그먼트에 대한 확인 응답 번호 포함

1. **A → B : ACK**
- A는 ACK 비트가 1로 설정된 세그먼트를 B에게 전송
- 세그먼트의 순서 번호에는 A의 순서 번호와 2에서 보낸 세그먼트에 대한 확인 응답 번호 포함

A는 “연결을 먼저 요청” → **Active Open**

B는 “요청을 수락” → **Passive Open**

클라이언트 - 서버 관계에서 액티브 오픈은 주로 클라이언트, 패시브 오픈은 주로 서버에 의해 수행

이 과정이 끝나면 **ESTABLISHED** 상태로 전환된다.

## TCP 신뢰성 보장을 위한 3대 기능

### 오류 제어 (재전송 기반)

**재전송 발생 조건**

- **중복 ACK 수신 (Dup ACK)**
    
    ![image.png](attachment:2d8c6f64-56b4-4f2a-92e7-82749a67e2b9:image.png)
    
    - 특정 세그먼트가 유실되었을 때

- **타임아웃(Time-out)**
    
    ![image.png](attachment:0cca798e-b2df-430c-8e00-c9abd58208b4:image.png)
    
    - TCP 세그먼트를 송신하는 호스트는 모두 재전송 타이머라는 값을 유지
    - 호스트는 세그먼트를 전송할 때마다 이 재전송 타이머 시작
    - 이 타이머의 카운트 다운이 끝난 상황을 Timeout
    - ACK가 Timeout 발생까지 오지 않으면 재전송

**Pipelining**

기본적인 TCP 송수신 방법은 한 번에 여러 세그먼트를 보낼 수 있는 상황에서도 확인 응답을 받기 전까지는 보낼 수 없다.

>> **한번에 하나의 세그먼트만 주고받아야 하는 비효율**

![image.png](attachment:5b4e37a6-3401-43aa-bfa4-a52f65a55641:image.png)

오늘날의 TCP는 **확인 응답을 받기 전이라도 여러 메시지를 보내는** 파이프라이닝 사용

### 흐름 제어 (Flow Control)

수신자가 처리 가능한 만큼만 데이터를 보내도록 제어

송신 호스트가 수신 호스트의 처리 속도를 고려하여 송수신 속도를 균일하게 맞추는 기능

- TCP 헤더의 **Window Size** 필드를 통해 수신자의 버퍼 크기 전달
- 버퍼 오버플로우 방지

### 혼잡 제어 (Congestion Control)

네트워크가 혼잡할 때 전송량을 조절한다.

- 혼잡 판단 기준:
    - 중복 ACK
    - 타임아웃

네트워크의 혼잡 가능성을 검출한 송신 호스트는 전송할 수 있는 최대 전송량을 송신하지 않고

혼잡 없이 전송할 수 있을 정도의 양인 **Congestion Window(혼잡 윈도우)**만큼만 송신

**AIMD 알고리즘 (혼잡 제어 알고리즘)**

- 혼잡 없으면: **윈도우 크기 +1씩 증가**
- 혼잡 발생하면: **윈도우 절반 감소**

![image.png](attachment:3f77a7f1-4021-4b8a-83b1-df59c2bcf3a3:image.png)

패킷을 보내고 그에 대한 응답이 수신되기까지의 시간을 RTT라 한다.

RTT(Round Trip Time)를 기준으로 동작하며, 톱니 형태의 혼잡 윈도우 변화를 보인다.

## TCP 연결 종료 (Four-Way Handshake)

TCP 종료는 4단계를 거친다.

![image.png](attachment:692d0609-333f-4e8f-a3c6-8bf2dc1189e7:image.png)

1. **A → B : FIN** (Active Close)
- 호스트 A는 FIN 비트가 1로 설정된 세그먼트를 B에게 전송

1. **B → A : ACK**
- 1에 대한 B의 응답
- B는 ACK 세그먼트를 호스트 A에게 전송

1. **B → A : FIN** (Passive Close)
- B는 FIN 세그먼트를 A에게 전송

1. **A → B : ACK**
- 3에 대한 A의 응답
- A는 ACK 세그먼트를 B에게 전송

그리고 A는 **TIME_WAIT** 상태로 잠시 대기한다.

(마지막 ACK가 유실되었을 경우 대비)

## TCP 상태 관리 (Stateful Protocol)

TCP는 여러 상태를 가지며 통신 과정에 따라 전이된다.

![image.png](attachment:41c70aef-6608-470d-9f64-93a53cf21be0:image.png)

### 연결 전 상태

- **CLOSED** : 아무 연결 없음
- **LISTEN** : 연결 대기 중(서버)

### 연결 수립 과정

- **SYN-SENT** : SYN 보냄 (Active Open)
- **SYN-RECEIVED** : SYN+ACK 보냄 (Passive Open)
- **ESTABLISHED** : 연결 완료

### 연결 종료 과정

- **FIN-WAIT-1** : FIN 전송
- **CLOSE-WAIT** : FIN 받고 ACK 보냄
- **FIN-WAIT-2** : ACK 받음
- **LAST-ACK** : FIN 보내고 ACK 기다림
- **TIME-WAIT** : 마지막 안정성 대기
- **CLOSED** : 종료 완료